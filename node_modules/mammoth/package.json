{
  "name": "mammoth",
  "version": "0.3.9",
  "author": {
    "name": "Michael Williamson",
    "email": "mike@zwobble.org"
  },
  "description": "Convert Word documents to simple HTML",
  "keywords": [
    "docx",
    "html",
    "office",
    "word"
  ],
  "main": "./lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/mwilliamson/mammoth.js.git"
  },
  "dependencies": {
    "bluebird": "~1.1.0",
    "sax": "~0.5.2",
    "underscore": "~1.6.0",
    "lop": "~0.2.8",
    "async": "~0.2.6",
    "nomnom": "~1.6.2",
    "jszip": "~2.2.0"
  },
  "devDependencies": {
    "mocha": "~1.8",
    "browserify": "~3.33.0",
    "license-sniffer": "~0.1.0",
    "duck": "~0.1.11",
    "uglify-js": "~2.4.8",
    "temp": "~0.7.0",
    "jshint": "^2.5.2"
  },
  "browser": {
    "./lib/unzip.js": "./browser/unzip.js"
  },
  "bin": {
    "mammoth": "bin/mammoth"
  },
  "scripts": {
    "pretest": "jshint lib tests",
    "test": "mocha tests --recursive"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://opensource.org/licenses/BSD-2-Clause"
    }
  ],
  "readme": "# Mammoth .docx to HTML converter\n\nMammoth is designed to convert .docx documents,\nsuch as those created by Microsoft Word,\nand convert them to HTML.\nMammoth aims to produce simple and clean HTML by using semantic information in the document,\nand ignoring other details.\nFor instance,\nMammoth converts any paragraph with the style `Heading 1` to `h1` elements,\nrather than attempting to exactly copy the styling (font, text size, colour, etc.) of the heading.\n\nThere's a large mismatch between the structure used by .docx and the structure of HTML,\nmeaning that the conversion is unlikely to be perfect for more complicated documents.\nMammoth works best if you only use styles to semantically mark up your document.\n\nThe following features are currently supported:\n\n* Headings.\n\n* Lists.\n\n* Customisable mapping from your own docx styles to HTML.\n  For instance, you could convert `WarningHeading` to `h1.warning` by providing an appropriate style mapping.\n  \n* Tables.\n  The formatting of the table itself, such as borders, is currently ignored,\n  but the formatting of the text is treated the same as in the rest of the document.\n  \n* Footnotes.\n\n* Images.\n\n* Bold, italics and underlines.\n\n* Links.\n\n* Line breaks.\n\n## Web demo\n\nThe easiest way to try out mammoth is to use the web demo:\n\n* Clone this repository\n* Run `make setup`\n* Open `browser-demo/index.html` in a web browser\n\n## Installation\n\n    npm install mammoth\n    \n## Usage\n\n### CLI\n\nYou can convert docx files by passing the path to the docx file and the output file.\nFor instance:\n\n    mammoth document.docx output.html\n\nIf no output file is specified, output is written to stdout instead.\n\n#### Images\n\nBy default, images are included inline in the output HTML.\nIf an output directory is specified by `--output-dir`,\nthe images are written to separate files instead.\nFor instance:\n\n    mammoth document.docx --output-dir=output-dir\n\nExisting files will be overwritten if present.\n\n#### Styles\n\nA custom style map can be read from a file using `--style-map`.\nFor instance:\n\n    mammoth document.docx output.html --style-map=custom-style-map\n    \nWhere `custom-style-map` looks something like:\n\n    p[style-name='Aside Heading'] => div.aside > h2:fresh\n    p[style-name='Aside Text'] => div.aside > p:fresh\n\n### Library\n\nIn node.js, mammoth can be required in the usual way:\n\n```javascript\nvar mammoth = require(\"mammoth\");\n```\n\nTo generate a standalone JavaScript file for the browser,\nuse `mammoth.browser.js` (generate using `make setup` if it is not already present).\nThis uses any loaded module system.\nIf no module system is found,\n`mammoth` is set as a window global.\n\n#### Basic conversion\n\nTo convert an existing .docx file to HTML, use `mammoth.convertToHtml`:\n\n```javascript\nvar mammoth = require(\"mammoth\");\n\nmammoth.convertToHtml({path: \"path/to/document.docx\"})\n    .then(function(result){\n        var html = result.value; // The generated HTML\n        var messages = result.messages; // Any messages, such as warnings during conversion\n    })\n    .done();\n```\n\nNote that `mammoth.convertToHtml` returns a [promise](http://promises-aplus.github.io/promises-spec/).\n\nYou can also extract the raw text of the document by using `mammoth.extractRawText`.\nThis will ignore all formatting in the document.\nEach paragraph is followed by two newlines.\n\n```javascript\nmammoth.extractRawText({path: \"path/to/document.docx\"})\n    .then(function(result){\n        var text = result.value; // The raw text\n        var messages = result.messages;\n    })\n    .done();\n```\n\n#### Custom style map\n\nBy default,\nMammoth maps some common .docx styles to HTML elements.\nFor instance,\na paragraph with the style name `Heading 1` is converted to a `h1` element.\nYou can pass in a custom map for styles by passing an options object with a `styleMap` property as a second argument to `convertToHtml`.\nA description of the syntax for style maps can be found in the section \"Writing style maps\".\nFor instance, if paragraphs with the style name `Section Title` should be converted to `h1` elements,\nand paragraphs with the style name `Subsection Title` should be converted to `h2` elements:\n\n```javascript\nvar mammoth = require(\"mammoth\");\n\nvar options = {\n    styleMap: [\n        \"p[style-name='Section Title'] => h1:fresh\",\n        \"p[style-name='Subsection Title'] => h2:fresh\"\n    ]\n};\nmammoth.convertToHtml({path: \"path/to/document.docx\"}, options);\n```\n\nTo more easily support style maps stored in text files,\n`styleMap` can also be a string.\nEach non-blank line is treated as a separate style mapping:\n\n```javascript\nvar options = {\n    styleMap: \"p[style-name='Section Title'] => h1:fresh\\n\" +\n        \"p[style-name='Subsection Title'] => h2:fresh\"\n};\n```\n\nUser-defined style mappings are used in preference to the default style mappings.\nTo stop using the default style mappings altogether,\nset `options.includeDefaultStyleMap` to `false`:\n\n```javascript\nvar options = {\n    styleMap: [\n        \"p[style-name='Section Title'] => h1:fresh\",\n        \"p[style-name='Subsection Title'] => h2:fresh\"\n    ],\n    includeDefaultStyleMap: false\n};\n```\n\n#### Custom image handlers\n\nBy default, images are converted to `<img>` elements with the source included inline in the `src` attribute.\nThis behaviour can be changed by setting the `convertImage` option to an [image converter](#image-converters) .\n\nFor instance, the following would replicate the default behaviour:\n\n```javascript\nvar options = {\n    convertImage: mammoth.images.inline(function(element) {\n        return element.read(\"base64\").then(function(imageBuffer) {\n            return {\n                src: \"data:\" + element.contentType + \";base64,\" + imageBuffer\n            };\n        });\n    })\n};\n```\n\n#### Underline\n\nBy default, the underlining of any text is ignored since underlining can be confused with links in HTML documents.\nThis behaviour can be changed by setting the `convertUnderline` option to `mammoth.underline.element(name)`.\n\nFor instance, suppose that a source document uses underlining for emphasis.\nThe following will wrap any underlined source text in `<em>` tags:\n\n```javascript\nvar options = {\n    convertUnderline: mammoth.underline.element(\"em\")\n};\n```\n\n#### Document transforms\n\nMammoth allows a document to be transformed before it is converted.\nFor instance,\nsuppose that document has not been semantically marked up,\nbut you know that any centre-aligned paragraph should be a heading.\nYou can use the `transformDocument` argument to modify the document appropriately:\n\n```javascript\nfunction transformElement(element) {\n    if (element.children) {\n        element.children.forEach(transformElement);\n    }\n    if (element.type === \"paragraph\") {\n        if (element.alignment === \"center\" && !element.styleId) {\n            element.styleId = \"Heading2\";\n        }\n    }\n    return element;\n}\n\nvar options = {\n    transformDocument: transformElement\n};\n```\n\nThe return value of `transformDocument` is used during HTML generation.\nThe original document (and any child elements) can be safely modified.\n\nThe above can be written more succinctly using the helper `mammoth.transforms.paragraph`:\n\n```javascript\n\nfunction transformParagraph(element) {\n    if (element.alignment === \"center\" && !element.styleId) {\n        element.styleId = \"Heading2\";\n    }\n    return element;\n}\n\nvar options = {\n    transformDocument: mammoth.transforms.paragraph(transformParagraph)\n};\n```\n\n### API\n\n#### `mammoth.convertToHtml(input, options)`\n\nConverts the source document to HTML.\n\n* `input`: an object describing the source document.\n  On node.js, the following inputs are supported:\n  \n    * `{path: path}`, where `path` is the path to the .docx file.\n    * `{buffer: buffer}`, where `buffer` is a node.js Buffer containing a .docx file.\n    \n  In the browser, the following inputs are supported:\n  \n    * `{arrayBuffer: arrayBuffer}`, where `arrayBuffer` is an array buffer containing a .docx file.\n  \n* `options` (optional): options for the conversion.\n  May have the following properties:\n  \n  * `styleMap`: controls the mapping of Word styles to HTML.\n     If `options.styleMap` is a string,\n     each non-blank line is treated as a separate style mapping.\n     If `options.styleMap` is an array,\n     each element is expected to be a string representing a single style mapping.\n     See \"Writing style maps\" for a reference to the syntax for style maps.\n\n  * `includeDefaultStyleMap`: by default,\n     the style map passed in `styleMap` is combined with the default style map.\n     To stop using the default style map altogether,\n     set `options.includeDefaultStyleMap` to `false`.\n  \n  * `transformDocument`: if set,\n    this function is applied to the document read from the docx file before the conversion to HTML.\n    \n  * `convertImage`: by default, images are converted to `<img>` elements with the source included inline in the `src` attribute.\n    Set this option to an [image converter](#image-converters) to override the default behaviour.\n    \n  * `convertUnderline`: by default, the underlining of any text is ignored.\n    Set this option to [`mammoth.underline.element(name)`](#underline) to override the default behaviour.\n\n* Returns a promise containing a result.\n  This result has the following properties:\n\n  * `value`: the generated HTML\n\n  * `messages`: any messages, such as errors and warnings, generated during the conversion\n\n#### `mammoth.extractRawText(input)`\n\nExtract the raw text of the document.\nThis will ignore all formatting in the document.\nEach paragraph is followed by two newlines.\n\n* `input`: an object describing the source document.\n  On node.js, the following inputs are supported:\n  \n    * `{path: path}`, where `path` is the path to the .docx file.\n    * `{buffer: buffer}`, where `buffer` is a node.js Buffer containing a .docx file.\n    \n  In the browser, the following inputs are supported:\n  \n    * `{arrayBuffer: arrayBuffer}`, where `arrayBuffer` is an array buffer containing a .docx file.\n\n* Returns a promise containing a result.\n  This result has the following properties:\n\n  * `value`: the raw text\n\n  * `messages`: any messages, such as errors and warnings\n\n#### Messages\n\nEach message has the following properties:\n\n* `type`: a string representing the type of the message, such as `\"warning\"`\n\n* `message`: a string containing the actual message\n\n#### Image converters\n\nAn inline image converter can be created by calling `mammoth.images.inline(func)`.\nThis creates an inline `<img>` element for each image in the original docx.\n`func` should be a function that has one argument called `element`.\nThis argument is the image element being converted,\nand has the following properties:\n\n* `read([encoding])`: read the image file with the specified encoding.\n  If no encoding is specified, a `Buffer` is returned.\n  \n* `contentType`: the content type of the image, such as `image/png`.\n\n`func` should return an object (or a promise containing an object) with a `src` property,\nwhich will be used as the `src` attribute on the `<img>` element.\n\nFor instance, the following replicates the default image conversion:\n\n```javascript\nmammoth.images.inline(function(element) {\n    return element.read(\"base64\").then(function(imageBuffer) {\n        return {\n            src: \"data:\" + element.contentType + \";base64,\" + imageBuffer\n        };\n    });\n})\n```\n\n#### `mammoth.transforms.paragraph(transformParagraph)`\n\nReturns a function that can be used as the `transformDocument` option.\nThis will apply the function `transformParagraph` to each paragraph element.\n`transformParagraph` should return the new paragraph,\nand is allowed to mutate the original paragraph.\n\n## Writing style maps\n\nA style map is made up of a number of style mappings separated by new lines.\n\nA style mapping has two parts:\n\n* On the left, before the arrow, is the document element matcher.\n* On the right, after the arrow, is the HTML path.\n\nWhen converting each paragraph,\nMammoth finds the first style mapping where the document element matcher matches the current paragraph.\nMammoth then ensures the HTML path is satisfied.\n\n### Freshness\n\nWhen writing style mappings, it's helpful to understand Mammoth's notion of freshness.\nWhen generating, Mammoth will only close an HTML element when necessary.\nOtherwise, elements are reused.\n\nFor instance, suppose one of the specified style mappings is `p[style-name='Heading 1'] => h1`.\nIf Mammoth encounters a .docx paragraph with the style name `Heading 1`,\nthe .docx paragraph is converted to a `h1` element with the same text.\nIf the next .docx paragraph also has the style name `Heading 1`,\nthen the text of that paragraph will be appended to the *existing* `h1` element,\nrather than creating a new `h1` element.\n\nIn most cases, you'll probably want to generate a new `h1` element instead.\nYou can specify this by using the `:fresh` modifier:\n\n`p[style-name='Heading 1'] => h1:fresh`\n\nThe two consective `Heading 1` .docx paragraphs will then be converted to two separate `h1` elements.\n\nReusing elements is useful in generating more complicated HTML structures.\nFor instance, suppose your .docx contains asides.\nEach aside might have a heading and some body text,\nwhich should be contained within a single `div.aside` element.\nIn this case, style mappings similar to `p[style-name='Aside Heading'] => div.aside > h2:fresh` and\n`p[style-name='Aside Text'] => div.aside > p:fresh` might be helpful.\n\n### Document element matchers\n\n#### Paragraphs and runs\n\nMatch any paragraph:\n\n```\np\n```\n\nMatch any run:\n\n```\nr\n```\n\nTo match a paragraph or run with a specific style,\nyou can reference the style by name.\nThis is the style name that is displayed in Microsoft Word or LibreOffice.\nFor instance, to match a paragraph with the style name `Heading 1`:\n\n```\np[style-name='Heading 1']\n```\n\nStyles can also be referenced by style ID.\nThis is the ID used internally in the .docx file.\nTo match a paragraph or run with a specific style ID,\nappend a dot followed by the style ID.\nFor instance, to match a paragraph with the style ID `Heading1`:\n\n```\np.Heading1\n```\n\n### HTML paths\n\n#### Single elements\n\nThe simplest HTML path is to specify a single element.\nFor instance, to specify an `h1` element:\n\n```\nh1\n```\n\nTo give an element a CSS class,\nappend a dot followed by the name of the class:\n\n```\nh1.section-title\n```\n\nTo require that an element is fresh, use `:fresh`:\n\n```\nh1:fresh\n```\n\nModifiers must be used in the correct order:\n\n```\nh1.section-title:fresh\n```\n\n#### Nested elements\n\nUse `>` to specify nested elements.\nFor instance, to specify `h2` within `div.aside`:\n\n```\ndiv.aside > h2\n```\n\nYou can nest elements to any depth.\n\n## Upgrading to later versions\n\n### 0.3.0\n\nIf you've defined custom style maps or used a document transform,\nyou will likely need to change your usage slightly.\nOtherwise, you should be able to continue using Mammoth as before.\n\n#### Custom style maps\n\nPrior to 0.3.0, Mammoth matched docx paragraphs using style IDs e.g. `p.Heading1`.\nThese IDs are used internally in the docx format,\nand are distinct from the style name\ni.e. the name shown by Microsoft Word or LibreOffice.\nAlthough Mammoth still supports matching styles by ID,\nmatching styles by name is preferred.\nFor instance, instead of:\n\n```p.AsideHeading => h1```\n\nprefer:\n\n```p[style-name='Aside Heading'] => h1```\n\n#### Document transforms\n\nPrior to 0.3.0,\nMammoth (misleadingly) assigned the style ID to a property called `styleName`.\nThe style ID is now assigned to a more appropriate property, `styleId`.\nThe `styleName` property is now set to the name of the style.\nTo preserve existing behaviour,\nany existing document transforms should be rewritten in one of two ways:\n\n* Set the `styleId` property instead of the `styleName` property\n\n* Set the `styleName` property to the name of the style, rather than the ID\n\n### 0.2.0\n\nThe function `mammoth.style()` was renamed to `mammoth.styleMapping()`.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mwilliamson/mammoth.js/issues"
  },
  "homepage": "https://github.com/mwilliamson/mammoth.js",
  "_id": "mammoth@0.3.9",
  "dist": {
    "shasum": "0925f9e1e488f44471c168364dc4a7cdf918cf24"
  },
  "_from": "mammoth@",
  "_resolved": "https://registry.npmjs.org/mammoth/-/mammoth-0.3.9.tgz"
}
